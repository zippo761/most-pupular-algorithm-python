r"""Выведите таблицу размером n*n, заполненную числами от 1 до n*n
  по спирали, выходящей из левого верхнего угла и закрученной по часовой стрелке, как показано в примере (здесь n=5)
  Sample Input:
    5

Sample Output:
    1 2 3 4 5
    16 17 18 19 6
    15 24 25 20 7
    14 23 22 21 8
    13 12 11 10 9
"""

"""
Ключевые теги относящиеся к задаче:
# списковые включения
# отладка
# дебаггер
# дизасемблирование
# cython

Входные даннные: int
Выходные это вывод через sys.stdout в консоль

Тестовые данные (возможные краевые случаи):

  """
from numba import njit
import numpy as np

def input_digit():
    try:
        digit = 10000
    except ValueError as exception:
        raise exception
    return digit


"Стоит проверить тип входных данных вашей программы, т.к. возможно вначале ошибка не появится, а делее вы столкнетесь" "с ней и начнете исправлять не тот участок кода и потратите время зря"


""" 
* Реализация структуры данных в коде"""
"4*n байта для переменной 'a'(list)"


def init_data(n):
    matrix_for_iter = [
        [0 for i in range(n)] for j in range(n)
    ]  # создаю матрицу n*n и заполняю нулями
    return matrix_for_iter


number = input_digit()
matrix = init_data(number)

"expect длина 'a' равна 'n'" "Представим что вы написали алгоритм который заполняет матрицу, но никак не можете понять почему итоговый результат" "не соотсетвует ожидаемому, стоит сделать тест, что созданный массив корректной длины. Например вы могли ошибится и " "сделать списковое включение длиной range(n+1) до n включительно"

"Подумайте о всех вещах, которые должны правильно работать, чтобы простая задача выдала корректный результат. " "Компоненты которые обеспечивают работу вашей программы похожи на части вашего приложения: все те классы, функции, модули, что вы написали." "В нашем случае части нашей программы это - массив, который имеет корректную длину и тип входных данных, который" "правильно был преобразован из типа str в тип int, без этих вещей наша программа не будет работать правильно, " "а далее все что остается это алгоитм который будет правильно итераровать по индексам. " "В других задачах или в вашем программном коде, таких компонентов" "может быть очень много и следует как раз таки проверять, что они выдают ожидаемый результат"

r"""
Возможные подходы к решению задачи:

    * Структура данных будет использоваться - вложенные списки или матрица.
    * Вложенные списки, это списки, по которым мы можем итерировать в любом направлении используя два индекса - например:
    
    matrix[index_row][index_column]
           ^^^^^^^^^   ^^^^^^^^^^
        индекс цифры    индекс по 
        по горизонтали  вертикали
    * Область\сценарии использования ???????????????????/
    
    * Преимущества и недостатки и особенности структуры данных ????????????????????/
    
    * Визуальное представление ![](ksnip_20190326-142756.png)
    
    * Демонстрация использования на практике
"""


@njit(cache=True)
def run_matrix(number, matrix):
    "24 байта для переменной 'k'"
    k = 1  # заполняю матрицу числом 'K' увеличивая его на 1 после заполнения каждого элемента
    "24 байта для переменной 'm'"
    m = 0  # 4 байте для переменной счётчик итераций спирали, увеличиваю на 1 на каждом витке спирали

    while (
        k <= number * number
    ):  # внешний цикл с 4  циклами пока k не заполнит всю матрицу n*n
        "24 байта для переменной 'i'"
        for i in range(
            m, number - m
        ):  # цикл заполняет верхнюю сторону спирали - на каждой итерации сужаем границы цикла
            matrix[m][i] = k  # на 'm' с каждой стороны
            k += 1
        for i in range(
            m + 1, number - m
        ):  # цикл заполняет правую сторону спирали, границы зависят от m
            matrix[i][number - m - 1] = k
            k += 1
        for i in range(
            number - m - 2, m - 1, -1
        ):  # заполняею нижнюю сторону спирали - зависит от m
            matrix[number - m - 1][i] = k
            k += 1
        for i in range(
            number - 2 - m, m, -1
        ):  # цикл заполняет левую сторону спирали - зависит от m
            matrix[i][m] = k
            k += 1
        m += 1

    return matrix

"""
* Оценка структуры данных по времени и памяти ???????????????????????
* Оценка стиля кодирования
python -m pylint  Matrix.py
"""

r"""
* Так как мы имеем матрицу\вложенные списки и мы знаем, что можем двигаться в цикле по списку и вправо, даже вниз 
    и так же в обратных направлениях, но возникает сложность сразу же как только нам предстоит подумать
    о том как провалится во внутрь спирали. Давайте разобьем задачу на части. Попробуем сначала заполнить матрицу
    по внешнему кольцу.
    Обязательно буду пользоваться в таких задачах дебаггером, т.к. интуитивно не понятно в каком месте мы остановимся и выполним
     не верное действие. На самом деле пользуясь отладчиком, все становится так наглядно, что ответы 
      сами должны всплыть рано или поздно. Хорошим 
     помощником так же будет если мы возьмем листик и нарисуем матрицу 5*5 (визуализировать сложные части алгоритма бывает полезно таким образом) и попробуем
    нарисовать индексы для каждой цифры т.е.  как нам двигаться вправо(самое простое), вниз, слево, вверх.
     --- запускаем алгоритм и смотрим по шагам что он делает ---
    Как только нам получилось заполнить матрицу по внешнему кольцу, вытекает следующая мысль, что можно завести счетчик
    кольца, который будет сужать матрицу по единичке во внутрь за цикл.
     --- запускаем алгоритм и смотрим по шагам что он делает ---
    Ну и самый последний граничный случай, это внешний цикл while, который говорит нам, что мы должны остановится все же 
    когда значение заполняемого числа не достигнет n*n
    
    * Сценарии использования ???????????????

    * Преимущества\недостатки алгоритма:
        Из преимуществ это хорошая читаемость алгоритма, как я считаю.
        
        Из недостатков высокая алгоритмическая сложность, что вызывает задержки при больших входных данных.

    * Визуальное предсталение  ---> дебаггер и рисунок на картине шагов с индексами
    * тестовые данные ---> смотрим tests/
    * Реализация алгоритма 
    * Демонстрация использования на практике
    * Тестирование ---> смотрим tests/
    
    * Временная и пространнственная оценка алгоритма
     - Time Complexity: O(N**2)
     
    Пространственная сложность алгоритма — это функция которая показывает 
    максимальное количество памяти, затрачиваемое алгоритмом для решения задачи указанного размера. 
     
     - Space Complexity: O(24H+576), где H это кол-во элементов в массиве 'a'. - линейная пространственная сложность.
    Пространственная сложность алгоритма реализуется путем вычисления объема памяти, требуемого алгоритмом
    Формула расчета сложности пространства алгоритма записывается в виде: 
    
    Сложность пространства = (Вспомогательное пространство) + (использование пространства входными значениями)
   
   * оценка стиля кодирования
"""

"""
* cython 
Фундаментальную природу Cython можно резюмировать следующим образом: Cython — это Python с типами данных C.

Ващ python код может быть так же обработан с помощью cython.

Но Cython — это гораздо больше, потому что параметры и переменные могут быть объявлены с типами данных C. Код, который 
манипулирует значениями Python и значениями C, можно свободно смешивать, при этом преобразования выполняются 
автоматически везде, где это возможно. Ведение счетчика ссылок и проверка ошибок операций Python также выполняются 
автоматически, и вам доступна вся мощь средств обработки исключений Python, включая операторы try-except и try-finally,
 — даже во время манипулирования данными C.


"""


if __name__ == '__main__':

    number = input_digit()
    matrix = init_data(number)
    matrix = np.array(matrix, dtype=np.int32)
    matrix = run_matrix(number, matrix)

    """for i in range(number):  # вывод на печать каждого элемента матрицы
        for j in range(number):
            print(matrix[i][j], end=" ")
        print()"""
